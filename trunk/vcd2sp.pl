#!/usr/bin/perl
#
# vcd2sp.pl: Converts a Verilog Value Change Dump
# to a spice digital vector stimulus.
#
# Date: February 14, 2008
# Author: Nathaniel Pinckney
#

use File::Basename;

package main;
# require "vcd2.conf";
require "vcd2.pl";

main();

sub print_header() {
	print ";**********************************************************************\n";
	print "; $basename.vec\n";
	print "; Digital Vector file for stimulus\n";
	print ";\n";
	print "; Automatically generated by vcd2sp from '$vcdFilename'\n";
	print "; Original .vcd file from $VCD{version} ($VCD{date})\n";
	print ";**********************************************************************\n";	
	print "\n";
}

sub print_wire_list() {
	print "RADIX ";
	foreach my $k (sort keys %{$VCD{'ports'}}) {
		my %port = %{$VCD{'ports'}{$k}};
		if(isSkip($port{'name'} =~ /(clk|reset|ph0|ph1|ph2)/i)) {
			next;
		}
		my $char;
		print '1' x portSize($port{'portnum'});
		print " ";
	}
	print "\n\n";
	
	print "IO ";
	foreach my $k (sort keys %{$VCD{'ports'}}) {
		my %port = %{$VCD{'ports'}{$k}};
		if(isSkip($port{'name'})) {
			next;
		}
		my $char;
		if($port{'type'} eq 'output') { $char = 'o'; }
		elsif($port{'type'} eq 'input') { $char = 'i'; }
		elsif($port{'type'} eq 'inout') { $char = 'b'; }
		print $char x portSize($port{'portnum'});
		print " ";
	}
	print "\n\n";
	
	print "VNAME ";
	# TODO: abstract into block...
	foreach my $k (sort keys %{$VCD{'ports'}}) {
		my %port = %{$VCD{'ports'}{$k}};
		
		if(isSkip($port{'name'})) {
			next;
		}
		if($port{'portnum'} =~ /\[(\d+):(\d+)\]/) {
			($start, $end) = ($2, $1);
			 for(my $i = $end; $i >= $start; $i--) {
			 	print uc($port{'name'}) . '[' . $i . ']' . ' ';
			}
		} elsif($port{'portnum'} =~ /\[(\d+)\]/) {
			print uc($port{'name'}) . '[' . $1 . ']' . ' ';
		} else {
			print uc($port{'name'}) . ' ';
		}
	}
	print "\n\n";
	
	foreach my $enablename (sort keys %enable) {
		print "ENABLE " . $enable{$enablename} . " ";
		# TODO: abstract into block...
		foreach my $k (sort keys %{$VCD{'ports'}}) {
				my %port = %{$VCD{'ports'}{$k}};
				if(isSkip($port{'name'})) {
					next;
				}
				my $char;
				if($port{'name'} eq $enablename) { $char = '1'; }
				else { $char = '0'; }
				print $char x portSize($port{'portnum'});
				print " ";
		}
		print "\n";
	}
	
	foreach my $timingname (sort keys %timing) {
		print "TDELAY " . $timing{$timingname} . " ";
		# TODO: abstract into block...
		foreach my $k (sort keys %{$VCD{'ports'}}) {
				my %port = %{$VCD{'ports'}{$k}};
				if(isSkip($port{'name'})) {
					next;
				}
				my $char;
				if($port{'name'} eq $timingname) { $char = '1'; }
				else { $char = '0'; }
				print $char x portSize($port{'portnum'});
				print " ";
		}
		print "\n";
	}
	
	foreach my $timingname (sort keys %intiming) {
		print "IDELAY " . $intiming{$timingname} . " ";
		# TODO: abstract into block...
		foreach my $k (sort keys %{$VCD{'ports'}}) {
				my %port = %{$VCD{'ports'}{$k}};
				if(isSkip($port{'name'})) {
					next;
				}
				my $char;
				if($port{'name'} eq $timingname) { $char = '1'; }
				else { $char = '0'; }
				print $char x portSize($port{'portnum'});
				print " ";
		}
		print "\n";
	}
	
	foreach my $timingname (sort keys %outtiming) {
		print "ODELAY " . $outtiming{$timingname} . " ";
		# TODO: abstract into block...
		foreach my $k (sort keys %{$VCD{'ports'}}) {
				my %port = %{$VCD{'ports'}{$k}};
				if(isSkip($port{'name'})) {
					next;
				}
				my $char;
				if($port{'name'} eq $timingname) { $char = '1'; }
				else { $char = '0'; }
				print $char x portSize($port{'portnum'});
				print " ";
		}
		print "\n";
	}
	print "\n";
}

sub printVectors() {
	my $oldclk;
	my $clk;
	my $oldtime;
	
	$resetcount=0;
	$runcount=0;
	
	foreach my $time (sort {$a <=> $b} keys %{$VCD{'dump'}}) {
		my %vector = %{$VCD{'dump'}{$time}};
		
		$oldclk = $clk;
		$clk = $vector{$clkname};
		if(($oldclk == 1 && $clk == 0 && $clkdir eq "fall") or
		   ($oldclk == 0 && $clk == 1 && $clkdir eq "rise")) {
			# Count run vs reset
			if($vector{'reset'} eq '1' || $vector{'resetb'} eq '0') { $resetcount++; }
			else { $runcount++; }
			# Print vector
			if($clkdelay == 1) { print1Vector($oldtime); }
			else { print1Vector($time);	}
		}
		$oldtime = $time;
	}
	# Print the last vector, inputs are XXX's
	%oldvector = %{$VCD{'dump'}{$oldtime}};
	print1Vector($oldtime, -1);
	
	print "\n";
}

sub print1Vector {
	my ($time) = @_;
	my %vector = %{$VCD{'dump'}{$time}};

	foreach my $k (sort keys %{$VCD{'ports'}}) {
		my %port = %{$VCD{'ports'}{$k}};
		# TODO: This should be a list
		if(isSkip($port{'name'})) {
			next;
		}
		if($port{'type'} eq 'output') {
			# output
			#if(! exists $oldvector{"$port{'name'}$port{'portnum'}"} || $oldvector{'reset'} == 1) {
			if(! exists $vector{"$port{'name'}$port{'portnum'}"} || $vector{'reset'} == 1) {
			#	print "ERROR: Time $time COULDN'T FIND $port{'name'}$port{'portnum'}\n"
				print "X" x portSize($port{'portnum'});	
			} else {
			#	print uc($oldvector{"$port{'name'}$port{'portnum'}"});
				print uc($vector{"$port{'name'}$port{'portnum'}"});
			}
		} elsif($port{'type'} eq 'input') {
			# input
			if(! exists $vector{"$port{'name'}$port{'portnum'}"}) {
			#	print "ERROR: Time $time COULDN'T FIND $port{'name'}$port{'portnum'}\n"
				print "X" x portSize($port{'portnum'});	
			} else {
				print uc($vector{"$port{'name'}$port{'portnum'}"});
			}
		} elsif($port{'type'} eq 'inout') { # Bidirectional
			# input
			if(! exists $vector{"$port{'name'}$port{'portnum'}"}) {
			#	print "ERROR: Time $time COULDN'T FIND $port{'name'}$port{'portnum'}\n"
				print "X" x portSize($port{'portnum'});	
			} else {
				print uc($vector{"$port{'name'}$port{'portnum'}"});
			}
		}
		print " ";
	}
	print "\n";
}

sub isSkip() {
	($in) = @_;
	if($in =~ /(clk|ph0|ph1|ph2)/i) {
		return 1;
	} else {
		return 0;
	}
}

sub writeSP() {
	open(SAVEOUT, ">&STDOUT");
	open(STDOUT, ">$basename.vec") or die("Can't open $basename.vec for writing");
	
	# Print header
	print_header();
	
	print_wire_list();
	
	#
	print "; define the units and switching points\n";
	print "; these parameters are defined in the test bench\n";
	#print "TUNIT $VCD{timescale}\n";
	print "TUNIT ns\n";
	print "PERIOD UNITLESSTC\n";
	print "SLOPE UNITLESSEDGE\n";
	print "VIH SUPPLY\n";
	print "VIL 0\n";
	print "VOH VOH\n";
	print "VOL VOL\n";
	print "VTH VSWITCH\n";
	print "\n";
		
	#
	print "; specify the vectors\n";
	print "; the first cycles are for reset\n";
	print "; check the output of the last cycle\n";
	print "; at the same time as applying inputs\n";
	print "; for the next cycle\n";
	
	# Print vectors here
	printVectors();
	
	close(STDOUT);
	open(STDOUT, ">&SAVEOUT") or die("Can't open original STDOUT");
}

sub main() {
	# Parse command line arguments
	$numArgs = $#ARGV + 1;
	$vcdFilename = $ARGV[$#ARGV];
	$basename = basename($vcdFilename, ".vcd");
	
	if($numArgs != 1) { usage() };
	
	eval('require "' . "$basename.conf" . '";') or die "Couldn\'t load config file $basename.conf";
	
	parseVCD();
	writeSP();
	writeDuration();
}

sub writeDuration() {
	open(SAVEOUT, ">&STDOUT");
	open(STDOUT,">duration_$basename.sp") or die("Can't open duration_$basename.sp for writing");
	
	print "***********************************************************************\n";
	print "* duration_$basename.sp\n";
	print "* Duration of simulation\n";
	print "*\n";
	print "* Automatically generated by vcd2sp from '$vcdFilename'\n";
	print "* Original .vcd file from $VCD{version} ($VCD{date})\n";
	print "***********************************************************************\n";
	print "\n";

	print "***********************************************************************\n";
	print "* Simulation Durations\n";
	print "***********************************************************************\n";
	# TODO: This timing needs some work.
	print ".param FIRSTCYCLE=$resetcount * first nonreset cycle\n";
	print ".param SIMCYCLES='FIRSTCYCLE+$runcount'\n";
	
	close(STDOUT);
	open(STDOUT, ">&SAVEOUT") or die("Can't open original STDOUT");
}

sub usage() {
	print STDERR "Usage: ./vcd2sp.pl input.vcd\n";
	exit;
}
